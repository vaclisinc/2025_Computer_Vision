<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project 3: (Auto)stitching and Photo Mosaics</title>
    <link rel="stylesheet" href="css/styles.css?v=1759909542">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>
<body>
    <!-- Desktop Viewing Notice -->
    <div class="desktop-notice">
        <p>üíª Best viewed on desktop (1920√ó1080 or larger) for optimal experience</p>
    </div>

    <!-- Header -->
    <header>
        <div class="header-content">
            <div class="header-info">
                <a href="../index.html" class="back-link">‚Üê Back to Projects</a>
                <br><br><br>
                <h1>Project 3: (Auto)stitching and Photo Mosaics</h1>
                <p class="subtitle">CS 180 Project 3 ¬∑ Song-Ze Yu</p>
            </div>

            <div class="overview-grid">
                <div class="overview-card">
                    <h3>Part A: Image Warping and Mosaicing</h3>
                    <p>Manually select correspondences, compute homographies, warp images, and blend them into seamless panoramas.</p>

                    <div class="part-nav-grid">
                        <a href="#part1-1-overview" class="part-nav-item">
                            <span class="part-nav-number">A.1</span>
                            <span class="part-nav-title"> Shoot the Pictures</span>
                        </a>
                        <a href="#part1-2-approach" class="part-nav-item">
                            <span class="part-nav-number">A.2</span>
                            <span class="part-nav-title">Recover Homographies</span>
                        </a>
                        <a href="#part1-3-approach" class="part-nav-item">
                            <span class="part-nav-number">A.3</span>
                            <span class="part-nav-title">Warp the Images</span>
                        </a>
                        <a href="#part1-4-approach" class="part-nav-item">
                            <span class="part-nav-number">A.4</span>
                            <span class="part-nav-title">Blend the Images into a Mosaic</span>
                        </a>
                    </div>
                </div>

                <div class="overview-card">
                    <h3>Part B: Feature Matching for Autostitching</h3>
                    <p style="font-style: italic; color: var(--text-muted);">Stay tuned.</p>

                    <div class="part-nav-grid">
                        <a href="#part2-1" class="part-nav-item">
                            <span class="part-nav-number">B.1</span>
                            <span class="part-nav-title">Harris</span>
                        </a>
                        <a href="#part2-2" class="part-nav-item">
                            <span class="part-nav-number">B.2</span>
                            <span class="part-nav-title">Descriptors</span>
                        </a>
                        <a href="#part2-3" class="part-nav-item">
                            <span class="part-nav-number">B.3</span>
                            <span class="part-nav-title">Matching</span>
                        </a>
                        <a href="#part2-4" class="part-nav-item">
                            <span class="part-nav-number">B.4</span>
                            <span class="part-nav-title">RANSAC</span>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="toc">
        <a href="#part1-1-overview">A.1: Shoot</a>
        <a href="#part1-2-approach">A.2: Homographies</a>
        <a href="#part1-3-approach">A.3: Warp</a>
        <a href="#part1-4-approach">A.4: Mosaic</a>
        <a href="#part2-1">B.1: Harris</a>
        <a href="#part2-2">B.2: Descriptors</a>
        <a href="#part2-3">B.3: Matching</a>
        <a href="#part2-4">B.4: RANSAC</a>
    </nav>

    <main>

        <!-- PART A: IMAGE MOSAICS -->

        <!-- Part A.1 Overview -->
        <section id="part1-1-overview" class="info-section">
            <div class="content-centered">
                <h2>Part A.1: Shoot the Pictures</h2>
                <p>I captured two sets of images with projective transformations by <strong>fixing the center of projection (COP)</strong> and <strong>rotating the camera</strong> while keeping the same position.</p>

                <div class="specs-grid" style="grid-template-columns: 1fr 1fr; max-width: 800px; margin: 2rem auto; gap: 3rem;">
                    <div class="spec-item" style="text-align: center;">
                        <h4 style="font-size: 1.2rem; margin-bottom: 0.5rem;">FOCAL LENGTH:</h4>
                        <p style="font-size: 1rem; font-weight: 500;">iPhone 14 Pro 1√ó lens</p>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.25rem;">(avoid barrel distortion by not using fisheye)</p>
                    </div>
                    <div class="spec-item" style="text-align: center;">
                        <h4 style="font-size: 1.2rem; margin-bottom: 0.5rem;">OVERLAP:</h4>
                        <p style="font-size: 1rem; font-weight: 500;">40~70%</p>
                        <p style="font-size: 0.9rem; color: var(--text-light); margin-top: 0.25rem;">Too little overlap makes registration harder.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Scene 1: IHouse Library -->
        <section class="scene-wrapper" id="scene-1">
            <div class="content-centered">
                <h3>Scene 1: [INDOOR] International House Library</h3>
                <p>This is where I spent most of my time during my exchange year in UC Berkeley.</p>
            </div>

            <div class="scroll-gallery-section">
                <div class="scroll-hint">
                    <p>üñ±Ô∏è Scroll to navigate through images horizontally</p>
                </div>
                <div class="scroll-gallery-container" id="gallery-ihouse">
                    <div class="scroll-gallery">
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_ihouse-library-01.jpg" alt="IHouse Library - Image 1" class="clickable">
                            <div class="scroll-gallery-caption">Image 1 - Left view</div>
                        </div>
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_ihouse-library-02.jpg" alt="IHouse Library - Image 2" class="clickable">
                            <div class="scroll-gallery-caption">Image 2 - Center-left</div>
                        </div>
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_ihouse-library-03.jpg" alt="IHouse Library - Image 3" class="clickable">
                            <div class="scroll-gallery-caption">Image 3 - Center-right</div>
                        </div>
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_ihouse-library-04.jpg" alt="IHouse Library - Image 4" class="clickable">
                            <div class="scroll-gallery-caption">Image 4 - Right view</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Scene 2: CNMAT -->
        <section class="scene-wrapper" id="scene-2">
            <div class="content-centered">
                <h3>Scene 2: [OUTDOOR] CNMAT Lab</h3>
                <p>This location is meaningful to me as it's where I conducted my undergraduate research.</p>
            </div>

            <div class="scroll-gallery-section">
                <div class="scroll-hint">
                    <p>üñ±Ô∏è Scroll to navigate through images horizontally</p>
                </div>
                <div class="scroll-gallery-container" id="gallery-cnmat">
                    <div class="scroll-gallery">
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_cnmat-upstair-01.jpg" alt="CNMAT Upstairs - Image 1" class="clickable">
                            <div class="scroll-gallery-caption">Image 1 - Left view</div>
                        </div>
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_cnmat-upstair-02.jpg" alt="CNMAT Upstairs - Image 2" class="clickable">
                            <div class="scroll-gallery-caption">Image 2 - Center-left</div>
                        </div>
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_cnmat-upstair-03.jpg" alt="CNMAT Upstairs - Image 3" class="clickable">
                            <div class="scroll-gallery-caption">Image 3 - Center-right</div>
                        </div>
                        <div class="scroll-gallery-item">
                            <img src="src/img/3A_1_cnmat-upstair-04.jpg" alt="CNMAT Upstairs - Image 4" class="clickable">
                            <div class="scroll-gallery-caption">Image 4 - Right view</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Part A.2 - Approach -->
        <section id="part1-2-approach">
            <div class="content">
                <h2>Part A.2: Recover Homographies</h2>
                <p>Compute the homography matrix <code>H</code> that maps points from one image to another.</p>

                <!-- <h3 style="text-align: center;">Approach</h3> -->
            </div>

            <!-- Two-column layout: Mathematical Formulation + Draft -->
            <div class="content-wide">
                <div class="two-column-layout">
                    <div class="column-left">
                        <h4>Mathematical Formulation</h4>
                        <p>For each correspondence pair <code>(x, y) ‚Üî (u, v)</code>, we construct two linear equations:</p>
                        <ul>
                            <li><code>h‚ÇÅx + h‚ÇÇy + h‚ÇÉ - h‚Çáux - h‚Çàuy = u</code></li>
                            <li><code>h‚ÇÑx + h‚ÇÖy + h‚ÇÜ - h‚Çávx - h‚Çàvy = v</code></li>
                        </ul>
                        <p>With <em>n</em> correspondence points, we build the system <code>Ah = b</code> where:</p>
                        <ul>
                            <li><code>A</code> is a <code>2n √ó 8</code> matrix containing the coordinates and their products</li>
                            <li><code>h</code> is an <code>8 √ó 1</code> vector of unknown homography coefficients</li>
                            <li><code>b</code> is a <code>2n √ó 1</code> vector of target coordinates</li>
                        </ul>
                        <p>We solve this using least-squares: <code>h = (A·µÄA)‚Åª¬πA·µÄb</code>, then reconstruct the <code>3√ó3</code> homography matrix with <code>h‚Çâ = 1</code>.</p>
                    </div>

                    <div class="column-right">
                        <div class="result-item">
                            <img src="src/img/3A_2_draft.jpg" alt="Homography derivation notes" class="clickable">
                            <div class="image-caption">Mathematical derivation</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </section>

        <!-- Part A.2 - Implementation -->
        <section id="part1-2-implementation" class="subsection">
            <div class="content">
                <h3>Implementation</h3>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Main Function: <code>computeH</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python"># File: part2_homography.py:69-92

def computeH(pts1, pts2):
    n = len(pts1)
    A = np.zeros((2*n, 8))
    b = np.zeros((2*n, 1))

    for i in range(n):
        x, y = pts1[i]
        u, v = pts2[i]

        A[2*i] = [x, y, 1, 0, 0, 0, -u*x, -u*y]
        b[2*i] = u

        A[2*i+1] = [0, 0, 0, x, y, 1, -v*x, -v*y]
        b[2*i+1] = v

    h, _, _, _ = np.linalg.lstsq(A, b, rcond=None)

    H = np.zeros((3, 3))
    H[0, :] = h[:3].flatten()
    H[1, :] = h[3:6].flatten()
    H[2, :2] = h[6:].flatten()
    H[2, 2] = 1

    return H, A, b</code></pre>
                </div>
            </div>

            <div class="note">
                <strong>Helper Functions (in <code>part2_homography.py</code>)</strong>
                <ul style="margin-top: 0.5rem;">
                    <li><code>select_correspondences()</code> ‚Äî Interactive point selection using matplotlib ginput</li>
                    <li><code>visualize_correspondences()</code> ‚Äî Draws correspondences on image pairs</li>
                    <li><code>save_correspondences(), load_correspondences()</code> ‚Äî Save and load selected points in json to avoid re-selecting</li>
                    <li><code>verify_homography(), print_system()</code> ‚Äî Displays the linear system and compute reprojection error for website demo</li>                </ul>
            </div>

            <div class="note" style="margin-top: 1.5rem;">
                <strong>Interactive Script (<code>part2_exec.py</code>) </strong>
                <p style="margin-top: 0.5rem; margin-bottom: 0;">An interactive CLI to detect the scene from images folder, choose which two images to process, decide how many correspondence points to mark, automatically save correspondences for future use</p>
                </ul>
            </div>
        </section>
        
        <!-- Part A.2 - Demo -->
        <section id="part1-2-demo" class="subsection">
            <div class="content">
                <h3>Demo: IHouse-Library </h3>
                <p>Using the interactive script, by selecting "ihouse-library" folder and picture 1 and 2, we manually click the points:</p>
            </div>

            <div class="demo-image-container">
                <img src="src/img/3A_2_ihouse-library_correspondences_viz_01_to_02.png" alt="IHouse-Library correspondences visualization" class="clickable">
            </div>

            <!-- Two-column layout: System + Homography -->
            <div class="content-wide">
                <p>Then, we get the (x,y) and (u,v), which can be written as the form matrix A (16√ó8) and b (16√ó1). Let's do <code>computeH()</code>:</p>

                <div class="demo-result-layout">
                    <div class="demo-input-section">
                        <div class="demo-section-label">INPUT: A, b</div>
                        <div class="demo-box">
                            <!-- <h4 class="demo-box-title">System: Ah = b (A: 16√ó8, b: 16√ó1)</h4> -->
                            <pre class="demo-code-block"><code>First 4 rows of A:
[[ 1.305e+03  1.229e+02  1.000e+00  0.000e+00 0.000e+00  0.000e+00 -7.926e+05 -7.462e+04]
 [ 0.000e+00  0.000e+00  0.000e+00  1.305e+03 1.229e+02  1.000e+00 -2.245e+05 -2.113e+04]
 [ 1.578e+03  9.773e+01  1.000e+00  0.000e+00 0.000e+00  0.000e+00 -1.306e+06 -8.086e+04]
 [ 0.000e+00  0.000e+00  0.000e+00  1.578e+03 9.773e+01  1.000e+00 -3.111e+05 -1.926e+04]
                                        ...                                             ]

First 4 rows of b:
[607.18
 171.96
 827.34
 197.12
  ...  ]</code></pre>
                        </div>
                    </div>

                    <div class="demo-arrow">‚Üí</div>

                    <div class="demo-output-section">
                        <div class="demo-section-label">OUTPUT: h (Least-squares Solution)</div>
                        <div class="demo-box">
                            <!-- <h4 class="demo-box-title">Least-squares Solution: h</h4> -->
                            <pre class="demo-code-block"><code>
[[ 2.916e+00]
 [-1.578e-01]
 [-2.272e+03]
 [ 6.617e-01]
 [ 2.247e+00]
 [-7.104e+02]
 [ 1.153e-03]
 [-1.504e-04]]


Mean error: 2.45 pixels
Max error:  3.22 pixels</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Part A.3: Warp the Images -->
        <section id="part1-3-approach">
            <div class="content">
                <h2>Part A.3: Warp the Images</h2>
                <p>In this part, we apply our Homography transformation in Part A.2 and warp two additional rectangle items using inverse warping with nearest neighbor and bilinear interpolation for vertification.</p>
            </div>

            <!-- Two-column layout: Mathematical Formulation + Draft -->
            <div class="content-wide">
                <div class="two-column-layout">
                    <div class="column-left">

                        <h4>Inverse Warping</h4>
                        <p>For each pixel <code>(u, v)</code> in our desired output image, we compute the corresponding source location using:</p>
                        <ul>
                            <li><code>[x_i, y_i, 1]·µÄ = H‚Åª¬π ¬∑ [u, v, 1]·µÄ</code></li>
                            <li>Normalize: <code>(x, y) = (x_i/w, y_i/w)</code> where <code>w</code> is the homogeneous coordinate</li>
                        </ul>

                        <h4>Nearest Neighbor</h4>
                        <p>Round to the nearest integer coordinates:</p>
                        <ul>
                            <li><code>x' = round(x), y' = round(y)</code></li>
                            <li>Sample: <code>output[u,v] = input[y', x']</code></li>
                            <!-- <li>Result: Fast but produces jagged edges</li> -->
                        </ul>

                        <h4>Bilinear Interpolation</h4>
                        <p>Weighted average of 4 neighboring pixels:</p>
                        <ul>
                            <li>Get floor coordinates: <code>x‚ÇÄ = ‚åäx‚åã, y‚ÇÄ = ‚åäy‚åã</code></li>
                            <li>Compute weights: <code>dx = x - x‚ÇÄ, dy = y - y‚ÇÄ</code></li>
                            <li>Four corner weights:
                                <ul>
                                    <li><code>w‚ÇÄ‚ÇÄ = (1-dx)(1-dy)</code></li>
                                    <li><code>w‚ÇÄ‚ÇÅ = (1-dx)¬∑dy</code></li>
                                    <li><code>w‚ÇÅ‚ÇÄ = dx¬∑(1-dy)</code></li>
                                    <li><code>w‚ÇÅ‚ÇÅ = dx¬∑dy</code></li>
                                </ul>
                            </li>
                            <!-- <li>Result: Smoother transitions, anti-aliased edges</li> -->
                        </ul>
                    </div>

                    <div class="column-right">
                        <div class="result-item">
                            <img src="src/img/3A_3_draft.jpg" alt="Inverse warping and interpolation notes" class="clickable">
                            <div class="image-caption">Mathematical derivation and visual explanation</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Part A.3 - Implementation -->
        <section id="part1-3-implementation" class="subsection">
            <div class="content">
                <h3>Implementation</h3>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Main Function: <code>warpImageNearestNeighbor</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def warpImageNearestNeighbor(im, H, output_shape=None):
    h, w = im.shape[:2]
    has_color = len(im.shape) == 3

    if output_shape is None:
        out_h, out_w, offset = compute_output_bounds(im.shape, H)
        T_offset = np.array([
            [1, 0, -offset[0]],
            [0, 1, -offset[1]],
            [0, 0, 1]
        ])
        H_adjusted = T_offset @ H
    else:
        out_h, out_w = output_shape
        H_adjusted = H

    if has_color:
        out_im = np.zeros((out_h, out_w, im.shape[2]))
    else:
        out_im = np.zeros((out_h, out_w))
    alpha = np.zeros((out_h, out_w))

    H_inv = np.linalg.inv(H_adjusted)

    y_coords, x_coords = np.meshgrid(np.arange(out_h), np.arange(out_w), indexing='ij')
    coords = np.stack([x_coords, y_coords, np.ones_like(x_coords)], axis=-1)

    src_h = coords @ H_inv.T
    denom = src_h[..., 2]

    with np.errstate(divide='ignore', invalid='ignore'):
        src_coords = src_h[..., :2] / denom[..., np.newaxis]

    safe_denom = np.isfinite(src_coords).all(axis=-1)

    src_x = np.round(src_coords[..., 0]).astype(int)
    src_y = np.round(src_coords[..., 1]).astype(int)

    valid = safe_denom & (src_x >= 0) & (src_x < w) & (src_y >= 0) & (src_y < h)
    out_im[valid] = im[src_y[valid], src_x[valid]]
    alpha[valid] = 1

    if has_color:
        result = np.zeros((out_h, out_w, 4), dtype=out_im.dtype)
        result[..., :3] = out_im
        result[..., 3] = alpha
    else:
        result = np.zeros((out_h, out_w, 2), dtype=out_im.dtype)
        result[..., 0] = out_im
        result[..., 1] = alpha

    return result</code></pre>
                </div>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Main Function: <code>warpImageBilinear</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def warpImageBilinear(im, H, output_shape=None):
    h, w = im.shape[:2]
    has_color = len(im.shape) == 3

    if output_shape is None:
        out_h, out_w, offset = compute_output_bounds(im.shape, H)
        T_offset = np.array([
            [1, 0, -offset[0]],
            [0, 1, -offset[1]],
            [0, 0, 1]
        ])
        H_adjusted = T_offset @ H
    else:
        out_h, out_w = output_shape
        H_adjusted = H

    if has_color:
        out_im = np.zeros((out_h, out_w, im.shape[2]))
    else:
        out_im = np.zeros((out_h, out_w))
    alpha = np.zeros((out_h, out_w))

    H_inv = np.linalg.inv(H_adjusted)

    y_coords, x_coords = np.meshgrid(np.arange(out_h), np.arange(out_w), indexing='ij')
    coords = np.stack([x_coords, y_coords, np.ones_like(x_coords)], axis=-1)

    src_h = coords @ H_inv.T
    denom = src_h[..., 2]

    with np.errstate(divide='ignore', invalid='ignore'):
        src_coords = src_h[..., :2] / denom[..., np.newaxis]

    safe_denom = np.isfinite(src_coords).all(axis=-1)

    src_x = src_coords[..., 0]
    src_y = src_coords[..., 1]

    x0 = np.floor(src_x).astype(int)
    x1 = x0 + 1
    y0 = np.floor(src_y).astype(int)
    y1 = y0 + 1

    valid = safe_denom & (x0 >= 0) & (x1 < w) & (y0 >= 0) & (y1 < h)

    dx = src_x - x0
    dy = src_y - y0

    w00 = (1 - dx) * (1 - dy)
    w01 = (1 - dx) * dy
    w10 = dx * (1 - dy)
    w11 = dx * dy

    if has_color:
        out_im[valid] = (
            w00[valid, np.newaxis] * im[y0[valid], x0[valid]] +
            w01[valid, np.newaxis] * im[y1[valid], x0[valid]] +
            w10[valid, np.newaxis] * im[y0[valid], x1[valid]] +
            w11[valid, np.newaxis] * im[y1[valid], x1[valid]]
        )
    else:
        out_im[valid] = (
            w00[valid] * im[y0[valid], x0[valid]] +
            w01[valid] * im[y1[valid], x0[valid]] +
            w10[valid] * im[y0[valid], x1[valid]] +
            w11[valid] * im[y1[valid], x1[valid]]
        )

    alpha[valid] = 1

    if has_color:
        result = np.zeros((out_h, out_w, 4), dtype=out_im.dtype)
        result[..., :3] = out_im
        result[..., 3] = alpha
    else:
        result = np.zeros((out_h, out_w, 2), dtype=out_im.dtype)
        result[..., 0] = out_im
        result[..., 1] = alpha

    return result</code></pre>
                </div>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Helper Function: <code>compute_output_bounds</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def compute_output_bounds(im_shape, H):
    h, w = im_shape[:2]
    corners = np.array([
        [0, 0, 1],
        [w-1, 0, 1],
        [0, h-1, 1],
        [w-1, h-1, 1]
    ])

    warped_corners = (H @ corners.T).T
    warped_corners = warped_corners[:, :2] / warped_corners[:, 2:3]

    min_x_i = int(np.floor(warped_corners[:, 0].min()))
    min_y_i = int(np.floor(warped_corners[:, 1].min()))
    max_x_i = int(np.ceil(warped_corners[:, 0].max()))
    max_y_i = int(np.ceil(warped_corners[:, 1].max()))

    out_w = (max_x_i - min_x_i) + 1
    out_h = (max_y_i - min_y_i) + 1

    offset = np.array([min_x_i, min_y_i])

    return out_h, out_w, offset</code></pre>
                </div>
            </div>

            <div class="note" style="margin-top: 1.5rem;">
                <strong>Interactive Script Usage</strong>
                <p style="margin-top: 0.5rem; margin-bottom: 0;">Similar to Part A.2, we used <code>part2_computeH</code> and the CLI script to select the four corners of rectangular objects for rectification.</p>
            </div>
        </section>

        <!-- Part A.3 - Demo -->
        <section id="part1-3-demo" class="subsection">
            <div class="content">
                <h3>Demo: Inverse Warping Comparison</h3>
                <p>We demonstrate both interpolation methods on a sample image. Notice the difference in edge quality:</p>
            </div>

            <div class="content-wide">
                <h4 style="text-align: center; margin-top: 2rem; margin-bottom: 1.5rem;">Demo 1</h4>
                <div class="image-grid" style="grid-template-columns: 1fr 1fr; gap: 2rem; margin: 0 auto;">
                    <div class="result-item" style="position: relative;">
                        <div class="scroll-hint" style="position: absolute; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 10; margin: 0;">
                            <p>üñ±Ô∏è Click to enlarge</p>
                        </div>
                        <img src="src/img/3A_3_S__31866900_0_demo_nn.png" alt="Demo - Nearest Neighbor" class="clickable">
                        <div class="image-caption"><strong>Nearest Neighbor (Runtime: 0.117s)</strong><br>Fast but produces jagged edges</div>
                    </div>
                    <div class="result-item" style="position: relative;">
                        <div class="scroll-hint" style="position: absolute; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 10; margin: 0;">
                            <p>üñ±Ô∏è Click to enlarge</p>
                        </div>
                        <img src="src/img/3A_3_S__31866900_0_demo_bilinear.png" alt="Demo - Bilinear" class="clickable">
                        <div class="image-caption"><strong>Bilinear Interpolation (Runtime: 0.260s)</strong><br>Smoother, anti-aliased results</div>
                    </div>
                </div>

                <h4 style="text-align: center; margin-top: 4rem; margin-bottom: 1.5rem;">Demo 2</h4>
                <div class="image-grid" style="grid-template-columns: 1fr 1fr; gap: 2rem; margin: 0 auto;">
                    <div class="result-item" style="position: relative;">
                        <div class="scroll-hint" style="position: absolute; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 10; margin: 0;">
                            <p>üñ±Ô∏è Click to enlarge</p>
                        </div>
                        <img src="src/img/3A_3_S__31866901_0_demo_nn.png" alt="Demo 2 - Nearest Neighbor" class="clickable">
                        <div class="image-caption"><strong>Nearest Neighbor (Runtime: 0.039s)</strong><br>Fast but produces jagged edges</div>
                    </div>
                    <div class="result-item" style="position: relative;">
                        <div class="scroll-hint" style="position: absolute; top: 1rem; left: 50%; transform: translateX(-50%); z-index: 10; margin: 0;">
                            <p>üñ±Ô∏è Click to enlarge</p>
                        </div>
                        <img src="src/img/3A_3_S__31866901_0_demo_bilinear.png" alt="Demo 2 - Bilinear" class="clickable">
                        <div class="image-caption"><strong>Bilinear Interpolation (Runtime: 0.088s)</strong><br>Smoother, anti-aliased results</div>
                    </div>
                </div>

            </div>
        </section>

        <!-- Part A.3 - Results -->
        <section id="part1-3-results" class="subsection">
            <!-- <div class="content"> -->
                <h3>Results: Image Rectification</h3>
                <p>Below are rectified and cropped images from two different scenes, including nearest neighbor and bilinear interpolation methods.</p>
            <!-- </div> -->

            <div class="content-wide">
                <h4 style="text-align: center; margin-top: 3rem; margin-bottom: 2rem;">Scene 1: Rectification Comparison</h4>
                <div class="image-grid" style="grid-template-columns: 1fr 1fr; gap: 2rem; max-width: 1000px; margin: 0 auto;">
                    <div class="result-item">
                        <img src="src/img/3A_3_S__31866900_0_rectified_nn.png" alt="Scene 1 - Nearest Neighbor" class="clickable">
                        <div class="image-caption"><strong>Nearest Neighbor</strong><br>Visible pixelation and jagged edges</div>
                    </div>
                    <div class="result-item">
                        <img src="src/img/3A_3_S__31866900_0_rectified_bilinear.png" alt="Scene 1 - Bilinear" class="clickable">
                        <div class="image-caption"><strong>Bilinear Interpolation</strong><br>Smooth transitions and clean edges</div>
                    </div>
                </div>

                <h4 style="text-align: center; margin-top: 4rem; margin-bottom: 2rem;">Scene 2: Rectification Comparison</h4>
                <div class="image-grid" style="grid-template-columns: 1fr 1fr; gap: 2rem; max-width: 1000px; margin: 0 auto;">
                    <div class="result-item">
                        <img src="src/img/3A_3_S__31866901_0_rectified_nn.png" alt="Scene 2 - Nearest Neighbor" class="clickable">
                        <div class="image-caption"><strong>Nearest Neighbor</strong><br>Sharp but aliased appearance</div>
                    </div>
                    <div class="result-item">
                        <img src="src/img/3A_3_S__31866901_0_rectified_bilinear.png" alt="Scene 2 - Bilinear" class="clickable">
                        <div class="image-caption"><strong>Bilinear Interpolation</strong><br>Natural, artifact-free result</div>
                    </div>
                </div>
            </div>

        </section>

        <!-- Part A.4: Blend the Images into a Mosaic -->
        <section id="part1-4-approach">
            <!-- <div class="content"> -->
                <h2>Part A.4: Blend the Images into a Mosaic</h2>
            <!-- </div> -->

            <div class="content-wide" style="max-width: 1000px; margin: 0 auto;">
                <div class="note" style="margin-top: 5rem;">
                    <strong>Reusing Components</strong>
                    <!-- <p style="margin-top: 0.5rem; font-size: large;">We reused components from earlier parts of the project:</p> -->
                    <ol style="margin-top: 0.5rem;">
                        <li><strong>Part A.2</strong>: Using saved correspondences and homographies that we manually clicked and stored.</li>
                        <li> <strong>Part A.3</strong>: Warping the left and right images onto the middle image using the verified bilinear interpolation.</li>
                    </ol>
                </div>

                <div class="note" style="margin-top: 1.5rem;">
                    <strong>Implementation Approach</strong>
                    <p style="margin-top: 0.5rem;">After aligning all images, we implemented <strong>weighted averaging</strong> to blend them together instead of simply overlapping.</p>
                    <p style="margin-top: 0.5rem;">In Part A.3, we already created an <strong>alpha mask</strong> for each image to define its visible region. The alpha values are further smoothed using a <strong>distance transform</strong>, giving higher weights near the image center and gradually fading toward the edges.</p>
                </div>
            </div>
        </section>

        <!-- Part A.4 - Implementation -->
        <section id="part1-4-implementation" class="subsection">
            <div class="content">
                <h3>Implementation</h3>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Distance Transform: <code>create_distance_alpha</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def create_distance_alpha(alpha_mask):
    """Convert binary alpha mask to distance-weighted alpha values"""
    dist = scipy.ndimage.distance_transform_edt(alpha_mask)
    max_dist = dist.max()
    if max_dist > 0:
        return dist / max_dist
    return alpha_mask.astype(float)</code></pre>
                </div>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Weighted Blending: <code>blend_images_weighted</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def blend_images_weighted(images_with_alpha, use_distance_blend=True):
    """Blend multiple images using distance-weighted alpha blending"""
    ref_h, ref_w = images_with_alpha[0].shape[:2]
    has_color = len(images_with_alpha[0].shape) == 3 and images_with_alpha[0].shape[2] == 4

    if has_color:
        output = np.zeros((ref_h, ref_w, 3))
    else:
        output = np.zeros((ref_h, ref_w))

    total_weight = np.zeros((ref_h, ref_w))

    for img in images_with_alpha:
        if has_color:
            rgb = img[..., :3]
            alpha = img[..., 3]
        else:
            rgb = img[..., 0]
            alpha = img[..., 1]

        # Apply distance-based weighting
        if use_distance_blend:
            alpha = create_distance_alpha(alpha > 0) * alpha

        output += rgb * alpha[..., np.newaxis] if has_color else rgb * alpha
        total_weight += alpha

    # Normalize by total weight
    valid = total_weight > 0
    if has_color:
        output[valid] /= total_weight[valid, np.newaxis]
    else:
        output[valid] /= total_weight[valid]

    return output</code></pre>
                </div>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Mosaic Creation: <code>create_mosaic</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def create_mosaic(images, H_list, ref_idx=0, use_distance_blend=True):
    """Create a mosaic from multiple images with computed homographies"""
    # Compute the bounding box for all warped images
    mosaic_h, mosaic_w, offset = compute_mosaic_bounds(images, H_list, ref_idx)

    # Adjust homographies to account for offset
    T_offset = np.array([[1, 0, -offset[0]], [0, 1, -offset[1]], [0, 0, 1]])

    warped_images = []

    # Warp each image to the common reference frame
    for i, im in enumerate(images):
        if i == ref_idx:
            H_adjusted = T_offset
        else:
            H_adjusted = T_offset @ H_list[i]

        warped = warpImageBilinear(im, H_adjusted, (mosaic_h, mosaic_w))
        warped_images.append(warped)

    # Blend all warped images
    mosaic = blend_images_weighted(warped_images, use_distance_blend)

    return mosaic, offset</code></pre>
                </div>
            </div>

            <div class="note" style="margin-top: 1.5rem;">
                <strong>Helper Function</strong>
                <ul style="margin-top: 0.5rem;">
                    <li><code>compute_mosaic_bounds()</code> ‚Äî Warps all image corners to find the bounding box of the final mosaic</li>
                </ul>
            </div>
        </section>

        <!-- Part A.4 - Results -->
        <section id="part1-4-results" class="subsection">
            <div class="content">
                <h3>Results: Final Mosaics</h3>
                <p>Below are the final panoramic mosaics created by blending three images from each scene. The distance-weighted alpha blending creates seamless transitions in overlapping regions.</p>
            </div>

            <div class="content-wide">
                <h4 style="text-align: center; margin-top: 3rem; margin-bottom: 2rem;">Mosaic 1: CNMAT Lab (Image 1, 2, 3)</h4>
                <div class="result-item" style="max-width: 1200px; margin: 0 auto;">
                    <img src="src/img/3A_4_mosaic2_cnmat_upstair_1_2_3_mosaic.png" alt="CNMAT Lab Mosaic" class="clickable">
                    <!-- <div class="image-caption">Seamless panorama of CNMAT upstairs area combining images 1, 2, and 3</div> -->
                </div>

                <h4 style="text-align: center; margin-top: 4rem; margin-bottom: 2rem;">Mosaic 2: International House Library (Image 2, 3, 4)</h4>
                <div class="result-item" style="max-width: 1200px; margin: 0 auto;">
                    <img src="src/img/3A_4_mosaic3_ihouse_library_2_3_4_mosaic.png" alt="IHouse Library Mosaic" class="clickable">
                    <!-- <div class="image-caption">Wide-angle view of IHouse Library combining images 2, 3, and 4</div> -->
                </div>
            </div>

        </section>

        <!-- PART B: FEATURE MATCHING FOR AUTOSTITCHING -->

        <!-- Part B.1: Harris Corner Detection -->
        <section id="part2-1">
            <div class="content">
                <h2>Part B.1: Harris Corner Detection</h2>
                <p>Automatic feature detection using Harris corners and Adaptive Non-Maximal Suppression (ANMS) to identify distinctive points for matching.</p>
            </div>

            <!-- Two-column layout: Mathematical Formulation + Theory -->
            <div class="content-wide">
                <div class="two-column-layout">
                    <div class="column-left">
                        <h4>Harris Corner Detection</h4>
                        <p>For each pixel, we compute the structure tensor matrix <code>M</code> using image gradients:</p>
                        <div style="text-align: center; margin: 1.5rem 0; font-family: 'JetBrains Mono', monospace;">
                            <div style="display: inline-block; position: relative;">
                                <span style="font-size: 1.2rem;">M = </span>
                                <span style="font-size: 2rem; vertical-align: middle;">[</span>
                                <div style="display: inline-block; vertical-align: middle; text-align: center;">
                                    <div><code>‚àëI¬≤‚Çì&nbsp;&nbsp;&nbsp;&nbsp;‚àëI‚ÇìI·µß</code></div>
                                    <div><code>‚àëI‚ÇìI·µß&nbsp;&nbsp;&nbsp;‚àëI¬≤·µß</code></div>
                                </div>
                                <span style="font-size: 2rem; vertical-align: middle;">]</span>
                            </div>
                        </div>
                        <p>The Harris response is calculated as:</p>
                        <ul>
                            <li><code>R = det(M) / trace(M)</code></li>
                            <li><code>R = (M‚ÇÅ‚ÇÅ¬∑M‚ÇÇ‚ÇÇ - M¬≤‚ÇÅ‚ÇÇ) / (M‚ÇÅ‚ÇÅ + M‚ÇÇ‚ÇÇ)</code></li>
                        </ul>
                        <p>Corners have large positive R values, edges have near-zero values, and flat regions have small values.</p>

                        <h4 style="margin-top: 2rem;">Adaptive Non-Maximal Suppression</h4>
                        <p>ANMS ensures spatial distribution of corners by:</p>
                        <ul>
                            <li>For each corner, find the minimum distance to a stronger corner (response > c √ó current)</li>
                            <li>Select the <code>n</code> points with largest minimum distances</li>
                            <li>This gives well-distributed features across the image</li>
                        </ul>

                        <div class="note" style="margin-top: 1rem; background: rgba(244, 172, 183, 0.1); border-left: 3px solid var(--accent);">
                            <strong>Intuition:</strong> Why does ANMS work?
                            <p style="margin-top: 0.5rem;">If a corner point has a large minimum distance to any stronger corner, it means:</p>
                            <ul style="margin-top: 0.5rem;">
                                <li>The point is relatively isolated and unique in its local region</li>
                                <li>It's not surrounded by many other strong corners (which would be redundant)</li>
                                <li>It likely represents a distinctive feature that's important for matching</li>
                            </ul>
                        </div>
                    </div>

                    <div class="column-right">
                        <div class="note" style="margin-top: 0;">
                            <strong>Algorithm Overview</strong>
                            <ol style="margin-top: 0.5rem;">
                                <li><strong>Gradient Computation</strong>: Calculate I‚Çì and I·µß using Sobel filters</li>
                                <li><strong>Structure Tensor</strong>: Build M matrix within a local window</li>
                                <li><strong>Response Calculation</strong>: Compute R for each pixel</li>
                                <li><strong>Peak Detection</strong>: Find local maxima above threshold</li>
                                <li><strong>ANMS Selection</strong>: Choose spatially distributed subset</li>
                            </ol>
                        </div>

                        <div class="note" style="margin-top: 1.5rem;">
                            <strong>Implementation Choice</strong>
                            <p style="margin-top: 0.5rem;">We use <code>skimage.feature.corner_harris</code> for robustness and efficiency, with custom ANMS implementation for spatial distribution.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Part B.1 - Implementation -->
        <section id="part2-1-implementation" class="subsection">
            <div class="content">
                <h3>Implementation</h3>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Harris Corner Detection: <code>get_harris_corners</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python"># from harris.py ref code
def get_harris_corners(im, edge_discard=20, min_dis=1, threshold=None):
    """
    This function takes a b&w image and an optional amount to discard
    on the edge (default is 5 pixels), and finds all harris corners
    in the image. Harris corners near the edge are discarded and the
    coordinates of the remaining corners are returned. A 2d array (h)
    containing the h value of every pixel is also returned.

    h is the same shape as the original image, im.
    coords is 2 x n (ys, xs).
    """
    assert edge_discard >= 20

    # find harris corners
    h = corner_harris(im, method='eps', sigma=1)
    coords = peak_local_max(h, min_distance=min_dis, threshold_rel=threshold)

    # discard points on edge
    edge = edge_discard  # pixels
    mask = (coords[:, 0] > edge) & \
           (coords[:, 0] < im.shape[0] - edge) & \
           (coords[:, 1] > edge) & \
           (coords[:, 1] < im.shape[1] - edge)
    coords = coords[mask].T
    return h, coords</code></pre>
                </div>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> ANMS Implementation: <code>anms</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def anms(h, coords, c=0.9, max_pts=500):
    """
    Adaptive Non-Maximal Suppression
    Select spatially distributed corners based on their response values
    """
    if coords.shape[1] <= max_pts:
        return coords

    h_vals = h[coords[0], coords[1]]
    n = coords.shape[1]

    coords_t = coords.T
    dists = dist2(coords_t, coords_t)

    r = np.zeros(n)
    for i in range(n):
        # Find points with stronger response than c * current point
        stronger = h_vals > c * h_vals[i]
        stronger[i] = False  # Exclude self

        if np.any(stronger):
            r[i] = np.min(dists[i, stronger])
        else:
            r[i] = np.inf

    # Handle infinite values
    r[r == np.inf] = np.max(r[r != np.inf]) + 1 if np.any(r != np.inf) else 0

    # Select top max_pts points with largest minimum distances
    selected = np.argpartition(-r, max_pts)[:max_pts]

    return coords[:, selected]</code></pre>
                </div>
            </div>

            <div class="code-section">
                <div class="code-header" onclick="toggleCode(this)">
                    <span class="toggle-icon">‚ñº</span> Distance Calculation: <code>dist2</code>
                </div>
                <div class="code-content">
                    <pre><code class="language-python">def dist2(x, c):
    """
    Calculates squared distance between two sets of points.
    Returns M x L matrix where entry (i,j) is squared distance
    from point i in x to point j in c.
    """
    ndata, dimx = x.shape
    ncenters, dimc = c.shape
    assert dimx == dimc, 'Data dimension does not match dimension of centers'

    return (np.ones((ncenters, 1)) * np.sum((x**2).T, axis=0)).T + \
            np.ones((ndata, 1)) * np.sum((c**2).T, axis=0) - \
            2 * np.inner(x, c)</code></pre>
                </div>
            </div>

            <div class="note" style="margin-top: 1.5rem;">
                <strong>Optimization Strategy</strong>
                <p style="margin-top: 0.5rem;">We can significantly improve performance by pre-filtering corners using <code>peak_local_max</code> parameters:</p>
                <ul style="margin-top: 0.5rem;">
                    <li><code>threshold_rel</code> ‚Äî Filters out weak corners below relative threshold</li>
                    <li><code>min_distance</code> ‚Äî Ensures minimum spacing between detected corners</li>
                </ul>
                <p style="margin-top: 0.5rem;">This pre-filtering removes noise points and reduces ANMS computation time from <strong>3m 29.9s</strong> to just <strong>0.4s</strong> for n=500 points.</p>
            </div>
        </section>

        <!-- Part B.1 - Demo/Results -->
        <section id="part2-1-demo" class="subsection">
            <div class="content">
                <h3>Demo: Performance Comparison</h3>
                <p>Comparing Harris corner detection with and without pre-filtering optimization on the same scene.</p>
            </div>

            <div class="content-wide">
                <h4 style="text-align: center; margin-top: 2rem; margin-bottom: 1.5rem;">Without Pre-filtering (Raw Harris Corners)</h4>
                <div class="result-item" style="max-width: 1000px; margin: 0 auto;">
                    <img src="src/img/B1-harris_anms_without_filter_comparison.png" alt="Harris corners without filtering" class="clickable">
                    <div class="image-caption">
                        <strong>Runtime: 3m 29.9s</strong><br>
                        Many noisy corners detected, ANMS takes significant time to process all points
                    </div>
                </div>

                <h4 style="text-align: center; margin-top: 3rem; margin-bottom: 1.5rem;">With Pre-filtering (Optimized)</h4>
                <div class="result-item" style="max-width: 1000px; margin: 0 auto;">
                    <img src="src/img/B1-harris_anms_with_filter_comparison.png" alt="Harris corners with filtering" class="clickable">
                    <div class="image-caption">
                        <strong>Runtime: 0.4s</strong><br>
                        Pre-filtered corners are higher quality, ANMS runs 500√ó faster with better spatial distribution
                    </div>
                </div>
            </div>
        </section>

        <!-- Part B.2: Feature Descriptor Extraction -->
        <section id="part2-2">
            <h2>Part B.2: Feature Descriptor Extraction</h2>
            <p><!-- Content to be added --></p>
        </section>

        <!-- Part B.3: Feature Matching -->
        <section id="part2-3">
            <h2>Part B.3: Feature Matching</h2>
            <p><!-- Content to be added --></p>
        </section>

        <!-- Part B.4: RANSAC -->
        <section id="part2-4">
            <h2>Part B.4: RANSAC</h2>
            <p><!-- Content to be added --></p>
        </section>
    </main>

    <!-- Lightbox -->
    <div id="lightbox" class="lightbox">
        <img id="lightbox-img">
        <span class="close">&times;</span>
    </div>

    <!-- Section Navigation for Part A.1 -->
    <div class="section-nav" id="part-a1-nav" style="display: none;">
        <div class="section-nav-dot" data-section="part1-1-overview" data-label="Overview"></div>
        <div class="section-nav-dot" data-section="scene-1" data-label="Scene 1"></div>
        <div class="section-nav-dot" data-section="scene-2" data-label="Scene 2"></div>
    </div>

    <!-- Section Navigation for Part A.2 -->
    <div class="section-nav" id="part-a2-nav" style="display: none;">
        <div class="section-nav-dot" data-section="part1-2-approach" data-label="Approach"></div>
        <div class="section-nav-dot" data-section="part1-2-implementation" data-label="Implementation"></div>
        <div class="section-nav-dot" data-section="part1-2-demo" data-label="Demo"></div>
    </div>

    <!-- Section Navigation for Part A.3 -->
    <div class="section-nav" id="part-a3-nav" style="display: none;">
        <div class="section-nav-dot" data-section="part1-3-approach" data-label="Approach"></div>
        <div class="section-nav-dot" data-section="part1-3-implementation" data-label="Implementation"></div>
        <div class="section-nav-dot" data-section="part1-3-demo" data-label="Demo"></div>
        <div class="section-nav-dot" data-section="part1-3-results" data-label="Results"></div>
    </div>

    <!-- Section Navigation for Part A.4 -->
    <div class="section-nav" id="part-a4-nav" style="display: none;">
        <div class="section-nav-dot" data-section="part1-4-approach" data-label="Approach"></div>
        <div class="section-nav-dot" data-section="part1-4-implementation" data-label="Implementation"></div>
        <div class="section-nav-dot" data-section="part1-4-results" data-label="Results"></div>
    </div>

    <!-- Section Navigation for Part B.1 -->
    <div class="section-nav" id="part-b1-nav" style="display: none;">
        <div class="section-nav-dot" data-section="part2-1" data-label="Approach"></div>
        <div class="section-nav-dot" data-section="part2-1-implementation" data-label="Implementation"></div>
        <div class="section-nav-dot" data-section="part2-1-demo" data-label="Demo"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        // Toggle code blocks
        function toggleCode(element) {
            const codeContent = element.nextElementSibling;
            const toggleIcon = element.querySelector('.toggle-icon');

            if (codeContent.style.display === 'none') {
                codeContent.style.display = 'block';
                toggleIcon.textContent = '‚ñº';
            } else {
                codeContent.style.display = 'none';
                toggleIcon.textContent = '‚ñ∂';
            }
        }

        // Image lightbox
        document.querySelectorAll('.clickable').forEach(img => {
            img.addEventListener('click', function() {
                const lightbox = document.getElementById('lightbox');
                const lightboxImg = document.getElementById('lightbox-img');
                lightbox.style.display = 'flex';
                lightboxImg.src = this.src;
            });
        });

        document.querySelector('.lightbox .close').addEventListener('click', function() {
            document.getElementById('lightbox').style.display = 'none';
        });

        document.getElementById('lightbox').addEventListener('click', function(e) {
            if (e.target === this) {
                this.style.display = 'none';
            }
        });

        // Smooth scroll
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                document.querySelector(this.getAttribute('href')).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });

        // Apple-style horizontal scroll galleries
        function initScrollGallery(galleryContainerId, sceneId) {
            const sceneWrapper = document.getElementById(sceneId);
            if (!sceneWrapper) {
                console.error('Scene wrapper not found:', sceneId);
                return;
            }

            const gallerySection = sceneWrapper.querySelector('.scroll-gallery-section');
            const galleryContainer = document.getElementById(galleryContainerId);
            if (!galleryContainer) {
                console.error('Gallery container not found:', galleryContainerId);
                return;
            }

            const gallery = galleryContainer.querySelector('.scroll-gallery');
            if (!gallery) {
                console.error('Gallery not found in:', galleryContainerId);
                return;
            }

            console.log('Initialized gallery:', galleryContainerId, 'in scene:', sceneId);

            let currentScrollPosition = 0;
            let maxScroll = 0;
            let isActive = false;

            function calculateMaxScroll() {
                maxScroll = gallery.scrollWidth - window.innerWidth;
                console.log('Max scroll for', galleryContainerId, ':', maxScroll);
            }

            function updateGalleryPosition() {
                gallery.style.transform = `translateX(-${currentScrollPosition}px)`;
            }

            function checkIfActive() {
                if (!sceneWrapper) return false;
                const rect = sceneWrapper.getBoundingClientRect();

                // Scene is active when it's fully in viewport (snapped)
                const active = rect.top >= -50 && rect.top <= 50;

                console.log('checkIfActive:', galleryContainerId, 'rect.top:', rect.top, 'active:', active);
                return active;
            }

            function handleWheel(e) {
                const wasActive = isActive;
                isActive = checkIfActive();

                console.log('Wheel event triggered, isActive:', isActive, 'galleryContainerId:', galleryContainerId);

                // Only handle wheel events when gallery section is in view
                if (isActive) {
                    const delta = e.deltaY;
                    const canScrollRight = delta > 0 && currentScrollPosition < maxScroll;
                    const canScrollLeft = delta < 0 && currentScrollPosition > 0;

                    console.log('Delta:', delta, 'canScrollRight:', canScrollRight, 'canScrollLeft:', canScrollLeft, 'currentPos:', currentScrollPosition);

                    if (canScrollRight || canScrollLeft) {
                        e.preventDefault();
                        e.stopPropagation();

                        // Smooth horizontal scroll with easing
                        const scrollAmount = delta * 0.6; // Slower, smoother
                        currentScrollPosition += scrollAmount;
                        currentScrollPosition = Math.max(0, Math.min(maxScroll, currentScrollPosition));

                        // Use requestAnimationFrame for smoother rendering
                        requestAnimationFrame(() => updateGalleryPosition());

                        console.log('Updated position to:', currentScrollPosition);
                    }
                }

                // Reset when entering scene
                if (isActive && !wasActive) {
                    currentScrollPosition = 0;
                    calculateMaxScroll();
                    updateGalleryPosition();
                    console.log('Scene became active, reset position');
                }
            }

            function handleScroll() {
                const rect = sceneWrapper.getBoundingClientRect();

                // Reset when scene is completely out of view
                if (rect.bottom < -100 || rect.top > window.innerHeight + 100) {
                    isActive = false;
                    currentScrollPosition = 0;
                    updateGalleryPosition();
                }
            }

            // Calculate initial max scroll
            calculateMaxScroll();
            window.addEventListener('resize', calculateMaxScroll);
            window.addEventListener('wheel', handleWheel, { passive: false });
            window.addEventListener('scroll', handleScroll, { passive: true });
        }

        // Initialize both galleries
        window.addEventListener('load', function() {
            console.log('Page loaded, initializing galleries...');
            initScrollGallery('gallery-ihouse', 'scene-1');
            initScrollGallery('gallery-cnmat', 'scene-2');
        });

        // Section Navigation
        const partA1Sections = ['part1-1-overview', 'scene-1', 'scene-2'];
        const sectionNav = document.getElementById('part-a1-nav');
        const navDots = sectionNav.querySelectorAll('.section-nav-dot');

        // Click handlers for navigation dots
        navDots.forEach(dot => {
            dot.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // Update navigation on scroll
        function updateSectionNav() {
            let currentSection = null;
            let isInPartA1 = false;
            let maxVisibleArea = 0;

            // Check which section is currently in view
            partA1Sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    const rect = section.getBoundingClientRect();

                    // Check if we're anywhere within this section's range
                    if (rect.top <= 200 && rect.bottom >= 0) {
                        isInPartA1 = true;
                    }

                    // Find the section with the most visible area in viewport
                    const viewportHeight = window.innerHeight;
                    const visibleTop = Math.max(0, rect.top);
                    const visibleBottom = Math.min(viewportHeight, rect.bottom);
                    const visibleArea = Math.max(0, visibleBottom - visibleTop);

                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        currentSection = sectionId;
                    }
                }
            });

            // Show/hide navigation based on whether we're in Part A.1
            if (isInPartA1) {
                sectionNav.style.display = 'flex';
            } else {
                sectionNav.style.display = 'none';
            }

            // Update active dot
            navDots.forEach(dot => {
                const dotSection = dot.getAttribute('data-section');
                if (dotSection === currentSection) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        // Listen to scroll events
        let scrollTimeout;
        window.addEventListener('scroll', function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(updateSectionNav, 10);
        }, { passive: true });

        // Initial check
        updateSectionNav();

        // Section Navigation for Part A.2
        const partA2Sections = ['part1-2-approach', 'part1-2-implementation', 'part1-2-demo'];
        const partA2Nav = document.getElementById('part-a2-nav');
        const partA2Dots = partA2Nav.querySelectorAll('.section-nav-dot');

        // Click handlers for Part A.2 navigation dots
        partA2Dots.forEach(dot => {
            dot.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // Update navigation on scroll for Part A.2
        function updatePartA2Nav() {
            let currentSection = null;
            let isInPartA2 = false;
            let maxVisibleArea = 0;

            // Check which section is currently in view
            partA2Sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    const rect = section.getBoundingClientRect();

                    // Check if we're anywhere within this section's range
                    if (rect.top <= 200 && rect.bottom >= 0) {
                        isInPartA2 = true;
                    }

                    // Find the section with the most visible area in viewport
                    const viewportHeight = window.innerHeight;
                    const visibleTop = Math.max(0, rect.top);
                    const visibleBottom = Math.min(viewportHeight, rect.bottom);
                    const visibleArea = Math.max(0, visibleBottom - visibleTop);

                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        currentSection = sectionId;
                    }
                }
            });

            // Show/hide navigation based on whether we're in Part A.2
            if (isInPartA2) {
                partA2Nav.style.display = 'flex';
            } else {
                partA2Nav.style.display = 'none';
            }

            // Update active dot
            partA2Dots.forEach(dot => {
                const dotSection = dot.getAttribute('data-section');
                if (dotSection === currentSection) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        // Section Navigation for Part A.3
        const partA3Sections = ['part1-3-approach', 'part1-3-implementation', 'part1-3-demo', 'part1-3-results'];
        const partA3Nav = document.getElementById('part-a3-nav');
        const partA3Dots = partA3Nav.querySelectorAll('.section-nav-dot');

        // Click handlers for Part A.3 navigation dots
        partA3Dots.forEach(dot => {
            dot.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // Update navigation on scroll for Part A.3
        function updatePartA3Nav() {
            let currentSection = null;
            let isInPartA3 = false;
            let maxVisibleArea = 0;

            // Check if Part A.4 has started
            const partA4FirstSection = document.getElementById('part1-4-approach');
            const isPartA4Started = partA4FirstSection && partA4FirstSection.getBoundingClientRect().top < 100;

            // Check which section is currently in view
            partA3Sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    const rect = section.getBoundingClientRect();

                    // Check if we're anywhere within this section's range (and Part A.4 hasn't started)
                    if (rect.top <= 200 && rect.bottom >= 0 && !isPartA4Started) {
                        isInPartA3 = true;
                    }

                    // Find the section with the most visible area in viewport
                    const viewportHeight = window.innerHeight;
                    const visibleTop = Math.max(0, rect.top);
                    const visibleBottom = Math.min(viewportHeight, rect.bottom);
                    const visibleArea = Math.max(0, visibleBottom - visibleTop);

                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        currentSection = sectionId;
                    }
                }
            });

            // Show/hide navigation based on whether we're in Part A.3
            if (isInPartA3) {
                partA3Nav.style.display = 'flex';
            } else {
                partA3Nav.style.display = 'none';
            }

            // Update active dot
            partA3Dots.forEach(dot => {
                const dotSection = dot.getAttribute('data-section');
                if (dotSection === currentSection) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        // Section Navigation for Part A.4
        const partA4Sections = ['part1-4-approach', 'part1-4-implementation', 'part1-4-results'];
        const partA4Nav = document.getElementById('part-a4-nav');
        const partA4Dots = partA4Nav.querySelectorAll('.section-nav-dot');

        // Click handlers for Part A.4 navigation dots
        partA4Dots.forEach(dot => {
            dot.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // Update navigation on scroll for Part A.4
        function updatePartA4Nav() {
            let currentSection = null;
            let isInPartA4 = false;
            let maxVisibleArea = 0;

            // Check which section is currently in view
            partA4Sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    const rect = section.getBoundingClientRect();

                    // Check if we're anywhere within this section's range
                    if (rect.top <= 200 && rect.bottom >= 0) {
                        isInPartA4 = true;
                    }

                    // Find the section with the most visible area in viewport
                    const viewportHeight = window.innerHeight;
                    const visibleTop = Math.max(0, rect.top);
                    const visibleBottom = Math.min(viewportHeight, rect.bottom);
                    const visibleArea = Math.max(0, visibleBottom - visibleTop);

                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        currentSection = sectionId;
                    }
                }
            });

            // Show/hide navigation based on whether we're in Part A.4
            if (isInPartA4) {
                partA4Nav.style.display = 'flex';
            } else {
                partA4Nav.style.display = 'none';
            }

            // Update active dot
            partA4Dots.forEach(dot => {
                const dotSection = dot.getAttribute('data-section');
                if (dotSection === currentSection) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        // Section Navigation for Part B.1
        const partB1Sections = ['part2-1', 'part2-1-implementation', 'part2-1-demo'];
        const partB1Nav = document.getElementById('part-b1-nav');
        const partB1Dots = partB1Nav.querySelectorAll('.section-nav-dot');

        // Click handlers for Part B.1 navigation dots
        partB1Dots.forEach(dot => {
            dot.addEventListener('click', function() {
                const sectionId = this.getAttribute('data-section');
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // Update navigation on scroll for Part B.1
        function updatePartB1Nav() {
            let currentSection = null;
            let isInPartB1 = false;
            let maxVisibleArea = 0;

            // Check which section is currently in view
            partB1Sections.forEach(sectionId => {
                const section = document.getElementById(sectionId);
                if (section) {
                    const rect = section.getBoundingClientRect();

                    // Check if we're anywhere within this section's range
                    if (rect.top <= 200 && rect.bottom >= 0) {
                        isInPartB1 = true;
                    }

                    // Find the section with the most visible area in viewport
                    const viewportHeight = window.innerHeight;
                    const visibleTop = Math.max(0, rect.top);
                    const visibleBottom = Math.min(viewportHeight, rect.bottom);
                    const visibleArea = Math.max(0, visibleBottom - visibleTop);

                    if (visibleArea > maxVisibleArea) {
                        maxVisibleArea = visibleArea;
                        currentSection = sectionId;
                    }
                }
            });

            // Show/hide navigation based on whether we're in Part B.1
            if (isInPartB1) {
                partB1Nav.style.display = 'flex';
            } else {
                partB1Nav.style.display = 'none';
            }

            // Update active dot
            partB1Dots.forEach(dot => {
                const dotSection = dot.getAttribute('data-section');
                if (dotSection === currentSection) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
        }

        // Update all navigations on scroll
        window.addEventListener('scroll', function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(function() {
                updateSectionNav();
                updatePartA2Nav();
                updatePartA3Nav();
                updatePartA4Nav();
                updatePartB1Nav();
            }, 10);
        }, { passive: true });

        // Initial check for Part A.2, A.3, A.4, and B.1
        updatePartA2Nav();
        updatePartA3Nav();
        updatePartA4Nav();
        updatePartB1Nav();

        // Desktop notice - hide when scrolling down from header
        const desktopNotice = document.querySelector('.desktop-notice');
        const header = document.querySelector('header');

        window.addEventListener('scroll', function() {
            if (!header || !desktopNotice) return;

            const headerRect = header.getBoundingClientRect();

            // Hide notice when header is scrolled past
            if (headerRect.bottom < 0) {
                desktopNotice.style.opacity = '0';
                desktopNotice.style.pointerEvents = 'none';
            } else {
                desktopNotice.style.opacity = '1';
                desktopNotice.style.pointerEvents = 'auto';
            }
        }, { passive: true });
    </script>
</body>
</html>
